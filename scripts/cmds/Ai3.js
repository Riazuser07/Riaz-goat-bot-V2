const axios = require('axios');
const fs = require('fs');
const path = require('path');
module.exports = {
config: {
name: "ai",
aliases: ["a"],
usePrefix: true,//true or False
version: "1.9",
author: "Delfin^‚Å∂‚Åπ",
countDown: 0,//countDown 1-100
role: 0,//role (0-Alluser) (1-Group Chat admin) (2-Admin bot)
shortDescription: {
vi: "‚ùé | error: module.exports.config.shortDescription.vi got null",
en: "Interact with an AI to get responses to your questions."
},
longDescription: {
vi: "‚ùé | error: module.exports.config.longDescription.vi got null",
en: "Interact with an AI to get responses to your questions." + "\nFor Dev;\nPlease make sure your api is Reachable by the axios"
},
category: "Education",
guide: {
vi: "‚ùé | error: module.exports.config.guide.vi got null",
en: "{pn} <question>"
 +"\n{pn} onFont to on the Font"
 +"\n{pn} offFont to off the Font"
},
priority: 1,
},
langs: {
vi: {
null: ""
},
en: {
null: ""
}
},
onStart: async function ({ api, args, message, event, threadsData, usersData, dashBoardData, globalData, threadModel, userModel, dashBoardModel, globalModel, role, commandName, getLang }) {
var directoryPath = path.join(__dirname, '..', 'events', 'cache');

// Check if the directory exists, if not, create it
if (!fs.existsSync(directoryPath)) {
    fs.mkdirSync(directoryPath, { recursive: true });
}

var dataPath = path.join(directoryPath, 'FontData.json');
var apis = path.join(directoryPath, 'apiDAta.json');

// Load or initialize the font flag data
let fontData;
if (fs.existsSync(dataPath)) {
    fontData = JSON.parse(fs.readFileSync(dataPath, 'utf8'));
} else {
    fontData = { [event.senderID]: { fontFlag: true } };
    fs.writeFileSync(dataPath, JSON.stringify(fontData));
    api.sendMessage("SYSTEM:\ndataPath installed ‚úÖ", event.threadID); // unsure what `messageID` refers to here
}
let apiData;
if (fs.existsSync(apis)) {
    apiData = JSON.parse(fs.readFileSync(apis, 'utf8'));
} else {
    apiData = { [event.senderID]: { link: "https://school-project-lianefca.bene-edu-ph.repl.co/ask/cassandra?query=", handlerData: `.message` } };
    fs.writeFileSync(apis, JSON.stringify(apiData));
    api.sendMessage("SYSTEM:\napiData installed ‚úÖ", event.threadID); // unsure what `messageID` refers to here
}
try {
  var link = (apiData[event.senderID]&&apiData[event.senderID].link); } catch (e) {
  apiData[event.senderID] = { link: "https://school-project-lianefca.bene-edu-ph.repl.co/ask/cassandra?query=", handlerData: `.message` };
fs.writeFileSync(apis, JSON.stringify(apiData));
}
try {
  var fontFlag = (fontData[event.senderID]&&fontData[event.senderID].fontFlag); } catch (e) {
  fontData[event.senderID] = { fontFlag: true };
fs.writeFileSync(dataPath, JSON.stringify(fontData));
} 
   var senderID = event.senderID;
   var senderName = await usersData.getName(event.senderID);
   	var mentionName = {
			mentions: [{
				id: senderID,
				tag: senderName
			}]};
			function Des(text){
			  const fontMapping = {
			    a: "ùìê", b: "ùìë", c: "ùìí", d: "ùìì", e: "ùìî", f: "ùìï", g: "ùìñ", h: "ùìó", i: "ùìò", j: "ùìô", k: "ùìö", l: "ùìõ", m: "ùìú", n: "ùìù", o: "ùìû", p: "ùìü", q: "ùì†", r: "ùì°", s: "ùì¢", t: "ùì£", u: "ùì§", v: "ùì•", w: "ùì¶", x: "ùìß", y: "ùì®", z: "ùì©"
			  };
			  let formattedText = "";
  for (const char of text) {
    if (char in fontMapping) {
      formattedText += fontMapping[char];
    } else {
      formattedText += char;
    }
  }
  return formattedText;
}
			function Bold(text) {
  const fontMapping = {
    a: "ùóÆ", b: "ùóØ", c: "ùó∞", d: "ùó±", e: "ùó≤", f: "ùó≥", g: "ùó¥", h: "ùóµ", i: "ùó∂", j: "ùó∑", k: "ùó∏", l: "ùóπ", m: "ùó∫",
    n: "ùóª", o: "ùóº", p: "ùóΩ", q: "ùóæ", r: "ùóø", s: "ùòÄ", t: "ùòÅ", u: "ùòÇ", v: "ùòÉ", w: "ùòÑ", x: "ùòÖ", y: "ùòÜ", z: "ùòá",
    A: "ùóî", B: "ùóï", C: "ùóñ", D: "ùóó", E: "ùóò", F: "ùóô", G: "ùóö", H: "ùóõ", I: "ùóú", J: "ùóù", K: "ùóû", L: "ùóü", M: "ùó†",
    N: "ùó°", O: "ùó¢", P: "ùó£", Q: "ùó§", R: "ùó•", S: "ùó¶", T: "ùóß", U: "ùó®", V: "ùó©", W: "ùó™", X: "ùó´", Y: "ùó¨", Z: "ùó≠", " ": "."
  };
  let formattedText = "";
  for (const char of text) {
    if (char in fontMapping) {
      formattedText += fontMapping[char];
    } else {
      formattedText += char;
    }
  }
  return formattedText;
}
			
   function formatFont(text) {
  const fontMapping = {
    a: "ùñ∫", b: "ùñª", c: "ùñº", d: "ùñΩ", e: "ùñæ", f: "ùñø", g: "ùóÄ", h: "ùóÅ", i: "ùóÇ", j: "ùóÉ", k: "ùóÑ", l: "ùóÖ", m: "ùóÜ",
    n: "ùóá", o: "ùóà", p: "ùóâ", q: "ùóä", r: "ùóã", s: "ùóå", t: "ùóç", u: "ùóé", v: "ùóè", w: "ùóê", x: "ùóë", y: "ùóí", z: "ùóì",
    A: "ùñ†", B: "ùñ°", C: "ùñ¢", D: "ùñ£", E: "ùñ§", F: "ùñ•", G: "ùñ¶", H: "ùñß", I: "ùñ®", J: "ùñ©", K: "ùñ™", L: "ùñ´", M: "ùñ¨",
    N: "ùñ≠", O: "ùñÆ", P: "ùñØ", Q: "ùñ∞", R: "ùñ±", S: "ùñ≤", T: "ùñ≥", U: "ùñ¥", V: "ùñµ", W: "ùñ∂", X: "ùñ∑", Y: "ùñ∏", Z: "ùñπ",
  };
  let formattedText = "";
  for (const char of text) {
    if (char in fontMapping) {
      formattedText += fontMapping[char];
    } else {
      formattedText += char;
    }
  }
  return formattedText;
}
 var question = args[0];
 var HandlerApisData = apiData[event.senderID].handlerData;
 switch (question) {
   case 'api':{
    const r = args[1];
const v = args[2];
if(!r){
  message.reply("Please Fill the api");
}
if(r&&!v){
  message.reply("Please Fill the HandlerApisData");
}
if (r.includes("(.)")&&v) {
  p = r.replace("(.)", ".");
  const Sub8 = await message.reply("‚úÖ | Api Updated");
  apiData[event.senderID] = { link: `${p}`, handlerData: `${v}` };
fs.writeFileSync(apis, JSON.stringify(apiData));
await api.setMessageReaction("üëç", event.messageID);
 await api.setMessageReaction("üíó", Sub8.messageID);
   setTimeout(async() => {
    await api.unsendMessage(Sub2.messageID);
    await api.setMessageReaction("üòÜ", Sub8.messageID);
  }, 12000);
   return Sub8;
}
if(r&&v.include(".")){
  apiData[event.senderID] = { link: `${r}`, handlerData: `${v}` };
fs.writeFileSync(apis, JSON.stringify(apiData));
const Sub8 = await message.reply("‚úÖ | Api Updated");
await api.setMessageReaction("üëç", event.messageID);
 await api.setMessageReaction("üíó", Sub8.messageID);
   setTimeout(async() => {
    await api.unsendMessage(Sub2.messageID);
    await api.setMessageReaction("üòÜ", Sub8.messageID);
  }, 12000);
   return Sub8;
}
if (!r.includes(".repl")) {
  message.reply("please make sure the api is hosted on replit");
}
 if (!v.toLowerCase().startsWith(".")) {
  message.reply("please make sure the  HandlerApisData have dot(at the starting of the line");
}
   }
 }
if (question === "onFont") {
  if (fontFlag === false) {
 fontData[event.senderID] = { fontFlag: true };
fs.writeFileSync(dataPath, JSON.stringify(fontData));
 const Sub2 = await message.reply("‚úÖ | Font activated");
 await api.setMessageReaction("üëç", event.messageID);
 await api.setMessageReaction("üíó", Sub2.messageID);
   setTimeout(async() => {
    await api.unsendMessage(Sub2.messageID);
    await api.setMessageReaction("üòÜ", Sub2.messageID);
  }, 12000);
   return Sub2;
} else {
  await api.setMessageReaction("üò†", event.messageID);
  const Sub3 = await message.reply("‚ùé | Font already activated!");
  await api.setMessageReaction("üëé", Sub3.messageID);
  setTimeout(async() => {
    await api.unsendMessage(Sub3.messageID);
    await api.setMessageReaction("üòÜ", Sub3.messageID);
  }, 12000);
  return Sub3;
}}

if (question === "offFont") {
  if (fontFlag === true) {
 fontData[event.senderID] = { fontFlag: false };
fs.writeFileSync(dataPath, JSON.stringify(fontData));
 const Sub4 = await message.reply("‚úÖ | Font deactivated");
 await api.setMessageReaction("üëç", event.messageID);
 await api.setMessageReaction("üíó", Sub4.messageID);
   setTimeout(async() => {
    await api.unsendMessage(Sub4.messageID);
    await api.setMessageReaction("üòÜ", Sub4.messageID);
  }, 12000);
   return Sub4;
} else {
  await api.setMessageReaction("üò†", event.messageID);
  const Sub5 = await message.reply("‚ùé | Font already deactivated!");
  await api.setMessageReaction("üëé", Sub5.messageID);
  setTimeout(async() => {
    await api.unsendMessage(Sub5.messageID);
    await api.setMessageReaction("üòÜ", Sub5.messageID);
  }, 12000);
  return Sub5;
}}
switch (question) {
  case 'imgs':{
   var k = args[1];
  var url1 = await axios.get(`https://api-all-1.arjhilbard.repl.co/pinterest?search=${encodeURIComponent(k)}`);
 const googleResponse = url1.data.data;
 if (!k) {
  const Sub = [ `ü§ñ ${formatFont("Hello")} ${Bold(senderName)}, \n${formatFont(`Please provide a question after the command. For example: "${global.GoatBot.config.prefix}ai test hello"`)}`, `${formatFont("Kindly provide the question at your convenience and I shall strive to deliver an effective response.")}\n${formatFont("Your satisfaction is my top priority.")}`];
     const happy = Sub[Math.floor(Math.random() * Sub.length)];
 var b = await message.reply(happy);
  await api.setMessageReaction("üò¢", event.messageID);
  await api.setMessageReaction("üò¢", b.messageID);
  setTimeout(async() => {
    await api.unsendMessage(b.messageID);
    await api.setMessageReaction("üòÜ", b.messageID);
  }, 12000);
 return b;
 }
var noob = await message.reply(`${formatFont("Searching‚Ä¢‚Ä¢‚Ä¢")}`);
 if(googleResponse){
   await api.unsendMessage(noob.messageID);
    await api.setMessageReaction("üòÜ", noob.messageID);
    const pinterestImageAttachments = [];
    const cacheDir = path.join(__dirname, 'cache');
    if (!fs.existsSync(cacheDir)) {
      fs.mkdirSync(cacheDir);
      return;
    }
    for (let i = 0; i < googleResponse.length; i++) {
      const imageUrls = googleResponse[i];
      try {
        const imageResponse = await axios.get(imageUrl, { responseType: "arraybuffer" });
        const imagePath = path.join(cacheDir, `pinterest_image${i + 1}.jpg`);
        fs.writeFileSync(imagePath, Buffer.from(imageResponse.data, "binary"));
        pinterestImageAttachments.push(fs.createReadStream(imagePath));
      } catch (error) {
        console.error("Error fetching Pinterest image:", error);
      }
      if (pinterestImageAttachments.length > 0) {
      message.reply(
        {
          attachment: pinterestImageAttachments,
          body: `${formatFont(`üì∑ ùóúùó∫ùóÆùó¥ùó≤ ùó¶ùó≤ùóÆùóøùó∞ùóµ ùó•ùó≤ùòÄùòÇùóπùòÅùòÄ ùó≥ùóºùóø: ${question}`)}`,
        } );
        return;
    }
    }
 }
    break;
}
}
if(fontFlag === true){
  if (question.toLowerCase().startsWith("hello") || question.toLowerCase().startsWith("hi")){
 await api.setMessageReaction("üíó", event.messageID);
  const lub1 = await message.reply(`ü§ñ ${formatFont("Hello")}`+ ` ${Bold(senderName)},\n` + `${formatFont("How can I assist you today?")}`);
  await api.setMessageReaction("üòç", lub1.messageID);
  setTimeout(async() => {
    await api.unsendMessage(lub1.messageID);
    await api.setMessageReaction("üòÜ", lub1.messageID);
    }, 12000);
    return lub1;
} 
if (!question) {
  const Sub = [ `ü§ñ ${formatFont("Hello")} ${Bold(senderName)}, \n${formatFont(`Please provide a question after the command. For example: "${global.GoatBot.config.prefix}ai hello"`)}`, `${formatFont("Kindly provide the question at your convenience and I shall strive to deliver an effective response.")}\n${formatFont("Your satisfaction is my top priority.")}`];
     const happy = Sub[Math.floor(Math.random() * Sub.length)];
 var b = await message.reply(happy);
  await api.setMessageReaction("üò¢", event.messageID);
  await api.setMessageReaction("üò¢", b.messageID);
  setTimeout(async() => {
    await api.unsendMessage(b.messageID);
    await api.setMessageReaction("üòÜ", b.messageID);
  }, 12000);
 return b;
 }
let infoMessage = [`‚ÑπÔ∏è${formatFont(" Answering your question")}` + ` ${Bold(senderName)}, ${Des("please wait...")}`,`‚è≥${Des("Typing‚Ä¢‚Ä¢‚Ä¢")}`];
const happy = infoMessage[Math.floor(Math.random() * infoMessage.length)];
 var a = await message.reply(happy);
 setTimeout(async() => {
    await api.unsendMessage(a.messageID);
    await api.setMessageReaction("üòÜ", a.messageID);
  }, 12000);
 await api.setMessageReaction("üíó", event.messageID);
 await api.setMessageReaction("üòç", infoMessage.messageID);
 try {
 const url = `${link}${encodeURIComponent(question)}`;
 let tries = 0;
 while (tries++ < 20) {
 try {
 const response = await this.fetchDataWithTimeout(url);
 const aiResponse = response.data+HandlerApisData;
 const c = await message.reply(`${formatFont("‚åõ Done‚úì")}`);
 setTimeout(async() => {
    await api.unsendMessage(c.messageID);
    await api.setMessageReaction("üòÜ", c.messageID);
  }, 12000);
  await api.setMessageReaction("üíó", event.messageID);
 await api.setMessageReaction("üòç", c.messageID);
await api.setMessageReaction("üòÜ", a.messageID);
 await api.unsendMessage(a.messageID);
var currentTimeDescription = `ü§ñ Hi ${Bold(senderName)}`;
 if(aiResponse){
   const reply = await message.reply(`${formatFont(currentTimeDescription)},\n${formatFont(aiResponse)}`);
     api.setMessageReaction("üòç", reply.messageID);
     setTimeout(async() => {
    await api.unsendMessage(reply.messageID);
    await api.setMessageReaction("üòÜ", reply.messageID);
  }, 3600000);
     return reply;
 } 
 } catch (error) {
 if (error.message.includes('Axios request is delayed')) {
 // increase delay for the next attempt
 await new Promise(res => setTimeout(res, 1000 * tries));
 continue;
 }
 throw error;
 }
 }
 throw new Error("Failed to fetch data after 20 attempts");
 } catch (error) {
 console.error(error);
 return message.reply(`${error.message}, please try again`);
 }
}
if(fontFlag === false){
if(question.toLowerCase().startsWith("hello")  || question.toLowerCase().startsWith("hi")) {
 await api.setMessageReaction("üòç", event.messageID);
  const lub = await message.reply(`Hello.${Bold(senderName)},\n` + `How can I assist you today?`); setTimeout(async() => {
    await api.unsendMessage(lub.messageID); 
    await api.setMessageReaction("üòÜ", lub.messageID);
    }, 12000); 
    return lub;
}
if (!question) {
  const Sub = await message.reply(`Please provide a question after the command. For example: "${global.GoatBot.config.prefix}ai hello"`);
  await api.setMessageReaction("üò¢", event.messageID);
  setTimeout(async() => {
    await api.unsendMessage(Sub.messageID);
    await api.setMessageReaction("üòÜ", Sub.messageID);
  }, 12000);
 return Sub;
 }
 var infoMessage = await message.reply(`‚ÑπÔ∏è Answering your question ${Bold(senderName)}, please wait...`);
 await api.setMessageReaction("üíó", event.messageID);
 await api.setMessageReaction("üòç", infoMessage.messageID);
try {
 const url = `${link}${encodeURIComponent(question)}`;
 let tries = 0;
 while (tries++ < 20) {
 try {
 const response = await this.fetchDataWithTimeout(url);
 const aiResponse = response.data+HandlerApisData;
await api.setMessageReaction("üòÜ", infoMessage.messageID);
 await api.unsendMessage(infoMessage.messageID);
var currentTimeDescription = `Hi ${Bold(senderName)}`;
 if(aiResponse) {
   const reply = await message.reply(`${currentTimeDescription} ,
     ${aiResponse}`);
     api.setMessageReaction("üòç", reply.messageID);
     setTimeout(async() => {
    await api.unsendMessage(reply.messageID);
    await api.setMessageReaction("üòÜ", reply.messageID);
  }, 3600000);
     return reply;
 }
 } catch (error) {
 if (error.message.includes('Axios request is delayed')) {
 // increase delay for the next attempt
 await new Promise(res => setTimeout(res, 1000 * tries));
 continue;
 }
 throw error;
 }
 }
 throw new Error("Failed to fetch data after 20 attempts");
 } catch (error) {
 console.error(error);
 return message.reply(`${error.message}, please try again`);
 }
}
},
fetchDataWithTimeout: async function (url1, url, timeout = 20000) {
 const controller = axios.CancelToken.source();
 setTimeout(() => {
 controller.cancel(`Axios request is delayed for ${timeout}ms, please try again`);
 }, timeout);
 return axios.get(url1, url, { cancelToken: controller.token });
 }
};
